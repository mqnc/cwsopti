
# pragma once

#include "utils.h"
#include <tinyply/tinyply.h>

struct float3 { float x, y, z; };
struct double3 { double x, y, z; };
struct triangle { uint32_t v1, v2, v3; };

Mesh read_ply_file(const std::string & fname)
{
	Mesh result;

	try
	{
		std::ifstream ss(fname, std::ios::binary);
		if (ss.fail()) throw std::runtime_error("failed to open " + fname);

		tinyply::PlyFile file;
		file.parse_header(ss);

		for (auto e : file.get_elements())
		{
			std::cout << "element - " << e.name << " (" << e.size << ")" << std::endl;
			for (auto p : e.properties) std::cout << "\tproperty - " << p.name << " (" << tinyply::PropertyTable[p.propertyType].str << ")" << std::endl;
		}

		std::shared_ptr<tinyply::PlyData> vertices, faces;

		try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

		try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); }
		catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

		file.read(ss);

		if (vertices) std::cout << "\tRead " << vertices->count << " total vertices "<< std::endl;
		if (faces) std::cout << "\tRead " << faces->count << " total faces (triangles) " << std::endl;

		if (vertices->t == Type::FLOAT32) {
			std::vector<float3> vbuffer(vertices->count);
			std::memcpy(vbuffer.data(), vertices->buffer.get(), vertices->buffer.size_bytes());

			result.v.resize(vertices->count);
			for (uint32_t i=0; i<vertices->count; i++){
				result.v[i] << vbuffer[i].x, vbuffer[i].y, vbuffer[i].z;
				result.v[i].normalize();
			}
		}
		if (vertices->t == Type::FLOAT64) {
			std::vector<double3> vbuffer(vertices->count);
			std::memcpy(vbuffer.data(), vertices->buffer.get(), vertices->buffer.size_bytes());

			result.v.resize(vertices->count);
			for (uint32_t i=0; i<vertices->count; i++){
				result.v[i] << vbuffer[i].x, vbuffer[i].y, vbuffer[i].z;
				result.v[i].normalize();
			}
		}

		std::vector<triangle> fbuffer(faces->count);
		std::memcpy(fbuffer.data(), faces->buffer.get(), faces->buffer.size_bytes());

		result.f.resize(faces->count);
		for (uint32_t i=0; i<faces->count; i++){
			result.f[i] = {fbuffer[i].v1, fbuffer[i].v2, fbuffer[i].v3};
		}
	}
	catch (const std::exception & e)
	{
		std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
	}

	return result;
}

void write_ply_file(const std::string & fname, Mesh & mesh)
{
	std::filebuf fb_binary;
	fb_binary.open(fname, std::ios::out | std::ios::binary);
	std::ostream outstream_binary(&fb_binary);
	if (outstream_binary.fail()) throw std::runtime_error("failed to open " + fname);

	tinyply::PlyFile meshfile;

	std::vector<float3> vbuffer(mesh.v.size());
	for(uint32_t i=0; i<mesh.v.size(); i++){
		vbuffer[i].x = mesh.v[i].x();
		vbuffer[i].y = mesh.v[i].y();
		vbuffer[i].z = mesh.v[i].z();
	}
	meshfile.add_properties_to_element("vertex", { "x", "y", "z" },
		Type::FLOAT32, vbuffer.size(), reinterpret_cast<uint8_t*>(vbuffer.data()), Type::INVALID, 0);

	std::vector<triangle> fbuffer(mesh.f.size());
	for(uint32_t i=0; i<mesh.f.size(); i++){
		fbuffer[i].v1 = mesh.f[i][0];
		fbuffer[i].v2 = mesh.f[i][1];
		fbuffer[i].v3 = mesh.f[i][2];
	}
	meshfile.add_properties_to_element("face", { "vertex_indices" },
		Type::UINT32, fbuffer.size(), reinterpret_cast<uint8_t*>(fbuffer.data()), Type::UINT8, 3);

	meshfile.get_comments().push_back("generated by tinyply 2.2");

	meshfile.write(outstream_binary, true);
}
